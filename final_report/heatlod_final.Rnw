\documentclass[11pt]{article}
\usepackage{fullpage,graphicx,float,amsmath,enumitem,hyperref}
\setlist{parsep=5.5pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Missing Data and LOD}
\rhead{Nnamdi Ezike, Paul Harmon, and Andrea Mack}
\setlength{\headheight}{18pt}
\setlength{\headsep}{2pt}

\title{Pea Lodging Final Report}
\author{Client: Jamin Smitchger\\
Consultants: Nnamdi Ezike, Paul Harmon, and Andrea Mack}
\date{December 16, 2016}

\begin{document}
\maketitle

<<setup, echo = FALSE, message = FALSE, cache = FALSE>>=
library(knitr)
opts_chunk$set(echo = FALSE, comment = NA, cache = TRUE, fig.align = "center",
               fig.width = 6.5, fig.height = 4, fig.pos = "H",
               size = "footnotesize", dev = "pdf",
               dev.args = list(pointsize = 11))
knit_theme$set("print")

library(xtable)
options(xtable.table.placement = "H", xtable.caption.placement = "top",
        width = 80, scipen = 1, show.signif.stars = FALSE)

library(TSA)
library(qtl)
library(mice)
library(ggplot2)
library(reshape2)


@

<<readin, include = FALSE>>=
# this data was extracted from the file
#Copy of MapDisto LOD 4, R=.15 with imputed and hets and distorteds remove-map written
# that was sent 112116 from Jamin -- see email

# gen_export is what map disto gave when I exported the data
# it is in an odd format that I don't know how to work with
#setwd("C:/Users/Paul/Documents/seminar_f16/final_report") #sets wd
gen_export <- read.table("datafromdisto_sent112116.txt", fill = TRUE)
str(gen_export)

# gen is what I copied directly from map disto
gen.raw <- read.csv("raw_copied.csv", as.is = TRUE)
gen <- read.csv("gen.csv", as.is = TRUE)
dim(gen)

###################################################################
# below was used to create data set
###################################################################
# make ind x markers
#gen <- t(gen)
#dim(gen)
# make row1 the column names
#colnames(gen) <- c(gen[1,])
# delete first row that was genetic marker identifiers
#gen <- gen[-1,]
#dim(gen)
#str(gen)
#write.csvs(gen, file = "gen.csv")
#gen <- apply(gen, 2, function(t){as.factor(as.character(t))})

#####################################################################

gen[gen == "-"] <- NA
gen <- apply(gen,2,function(t){factor(t,levels = c("A", "B"))})
gen <- data.frame(gen)

# remove blank first column
gen <- gen[,-1]

# converting data to long form for ggplot2 use

gen$ind <- c(seq(1:257))
gen$ind <- as.factor(as.character(gen$ind))

colnames(gen) <- substring(colnames(gen),1,7)

datf1_bz16 <- melt(gen, id.var = 'ind', na.rm = FALSE)
datf1_bz16[is.na(datf1_bz16)] <- "missing"
@

\section{Introduction}
Jamin is a Ph.D. student in the Department of Plant Sciences and Plant Pathology at MSU. The primary focus is his research is to associate variation in genetic expression with variation in the expression of several phenotypic traits. Genotypic and pheynotypic data were collected on 257 varieties of pea, from two locations (Bozeman and Moccasin), over 4 years. Phenotypic data includes percent lodging, tendril length, tendril node length, nodes at 1st flow, maximum number of nodes, germination, number of branches, plant height, plant length, average total yield, main stem diameter, tiller diameter, ``comp" tiller diameter, and maturation time, totaling 14 traits. Data from 609 genetic markers were collected. The end result of Jamin's research will include a quantitative trait loci (QTL) analysis. Prior to the QTL analysis, understanding of the data and methods are necessary. The report includes:

\begin{itemize}

\item Evaluation of correlations in pheynotypic data

\item Analysis of combining data from the different sites and years

\item Exploration of the rate of missing data

\item Explanation of significance thresholds for QTL 

\item Suggestions for future work
\end{itemize}
\pagebreak

\section{Correlation Plots}
Correlation describes the strength and direction of a linear association. Specifically, this analysis examines Pearson Correlations because the variables are measured on a quantitative scale.  Correlation is measured on a scale between -1 (a perfect negative linear association) and 1 (a perfect positive linear association). Correlation does not imply causal relationships. In examining, for instance, the relationship between lodging and stem width, the Pearson Correlation would only give information about the linear association between the two variables.  A strong association between the two variables cannot be interpreted that changes in stem width cause changes in lodging; rather, we would simply say that the two variables are associated with each other. Other confounding variables, such as climate, may be driving both. Since the phenotypes in each year at each site are considered separate response values, we consider examining plots of correlation matrices for each site/year combination as well as for the entire dataset. This allows for direct examination of linear relationships between covariates; however, non-linear relationships may not be accurately measured by Pearson correlation. Further investigation of outlying values in the data may be necessary as Pearson correlations are sensitive to the presence of outliers in the data. 

\subsection{Sites and Years Combined}
The correlation between pairwise explanatory variables of the phenotypic data were assessed using the a pairwise correlation matrix. We assessed the pairwise correlations across sites for pairs of explanatory variables which were measured within these sitesin at least two different years.

In Moccasin, only four variables were observed to have been measured both in 2015 and 2016. Of these variables, the length and main stem diameter of the plants are moderately correlated (r=-0.55). Also, the main stem diameter and root diameter of the plants are moderately correlated (r=0.45).
\pagebreak
\subsection{Bozeman in All Years}
The pairwise correlation matrix below shows that germination which was measured in Bozeman for all 3 years has weak correlation against all the variables measured. Also results from Bozeman shows that tendril length node of the plant was moderately to strongly correlated with the average length and tendril length of the plant with correlation coefficients of 0.61 and 0.48 respectively. The branch number and tiller diameter of the plant were also moderately correlated (r = 0.47). The maturity time of the plant was strongly and moderately correlated with the maximum nodes (r=0.65) and nodes of 1st flow (r=0.48). In addition, a correlation coefficient of 0.81 was observed for nodes 1st flow and maximum nodes of the plants.

<<merged, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 6, fig.cap = "Correlation Plot for Bozeman (In All Years)">>=
##Load Data (Bozeman 2014)
#setwd("C:/Users/Paul/Documents")
mergedbzn1<-read.csv("Merged Bozeman.csv",header=T)
#summary(mergedbzn)
#names(mergedbzn)

##Relabeling COlumns

library(data.table)

colnames(mergedbzn1)[colnames(mergedbzn1)=="Prcnt.Lodging"] <- "prcnt_lodging"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Germination.2014.."] <- "germ"
colnames(mergedbzn1)[colnames(mergedbzn1)=="branch.numb.2014"] <- "branch_numb"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Height"] <- "plant_height"
colnames(mergedbzn1)[colnames(mergedbzn1)=="length"] <- "plant_length"
colnames(mergedbzn1)[colnames(mergedbzn1)=="tendril.length.14.node.2014"] <- "tendril_length_node"
colnames(mergedbzn1)[colnames(mergedbzn1)=="tendril.length.2014"] <- "tendril_length"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Nodes.1st.flow.2014"] <- "nodes_1st_flow"
colnames(mergedbzn1)[colnames(mergedbzn1)=="max.nodes.2014"] <- "max_nodes"
colnames(mergedbzn1)[colnames(mergedbzn1)=="internode.length.2014"] <- "internode_length"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Total.yield.2014"] <- "total_yield"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Avg.Yld.Plant.2014"] <- "avg_total_yield"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Main.stm.diameter.2014"] <- "main_stm_diam"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Average.compressed.main.stem.thickness.2014"] <- "comp_main_stm"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Tiller.diameter.2014"] <- "tiller_diam"
colnames(mergedbzn1)[colnames(mergedbzn1)=="compressed.tiller.thickness.2014"] <- "comp_tiller_diam"
colnames(mergedbzn1)[colnames(mergedbzn1)=="length.1"] <- "length_1"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Maturity.Time"] <- "mat_time"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Tendril.Width"] <- "tendril_Width"
colnames(mergedbzn1)[colnames(mergedbzn1)=="Root.compressed.avg"] <- "root_comp"
colnames(mergedbzn1)[colnames(mergedbzn1)=="avg.main..side.brnch.root"] <- "main_stm_branch"

#names(mergedbzn)

##Drop Columns

mergedbzn1 <- subset(mergedbzn1, select = -c(Year,DNA.GENERATION, LINE.., Germination.2014NACHECKED, 
                                           stand.good.1.Y..2.bad.sample..do.not.use.lines.labeled.2, 
                                           prcnt.lodging.bad.germ.lines.includedNAchecked, flowering.time.2014,
                                           white.flower..1.is.white, black.hilum.delta.A.NO.MOT, 
                                           Brown.mottle..rerate.next.year..1.no.mot, np.neo, Late,
                                           tall.dwf.based.on.grnhouse.data..field.2014, Afila.1.YES.DELTA.A,
                                           internode_length, total_yield, comp_main_stm, length_1,
                                           tendril_Width, root_comp, main_stm_branch))


#names(mergedbzn)

##Reorder Columns
mergedbzn = mergedbzn1[,c(5,2,3,4,14,1,7,11,6,8:10,12:13)]
#names(mergedbzn)

##Plot Correlation
#install.packages("psych")
require(psych)
library(corrplot)
str(mergedbzn)
#pairs.panels(mergedbzn)
mergedbzn$germ <- as.numeric(mergedbzn$germ)
correlation.1 <- cor(mergedbzn[,1:13], use = "pairwise.complete.obs")
corrplot.mixed(correlation.1, tl.pos = 'lt', upper = "square", tl.cex = .7, number.cex = .75,bg = NULL)

@


<<siteyear, include = TRUE, eval = TRUE, warning = FALSE>>=
#setwd("C:/Users/Paul/Documents")
bz13 <- read.csv("JaminB13.csv", header = TRUE)
bz14 <- read.csv("JaminB14.csv", header = TRUE)
bz15 <- read.csv("JaminB15edited.csv", header = TRUE)
bz16 <- read.csv("JaminB16edited.csv", header = TRUE)
moc15 <- read.csv("JaminM15edited.csv", header = TRUE)
moc16 <- read.csv("JaminM16edited.csv", header = TRUE)

#create and add in variables for each site/year combination
bz13$Site <- bz14$Site <- bz15$Site <- bz16$Site <- "Bozeman"
moc15$Site <- moc16$Site <- "Moccasin"
bz13$Year <- 2013
bz14$Year <- 2014
bz15$Year <- moc15$Year <- 2015
bz16$Year <- moc16$Year <- 2016

#Merge into a single dataset
#lodging response
lodging<- c(bz14$Prcnt.Lodging,bz15$X..Lodging,bz16$pctg_Lodging_boze_2016,moc15$Lodging,moc16$X.lodging.2016)
#site year combo as a factor
site <- c(bz14$Site,bz15$Site, bz16$Site,moc15$Site,moc16$Site)
year <- c(bz14$Year, bz15$Year,bz16$Year,moc15$Year,moc16$Year)
siteyear <- as.factor(paste(site,year, sep = ""))

year.site.mat <- matrix(cbind(lodging,site,year,siteyear))
@

\subsection{Bozeman by Year}
We assessed the pairwise correlation of the different sites each year. In 2014, twelve pairs of explanatory variables had correlation coefficients between 0.42 and 0.91. The pairwise correlations are shown in the matrix below. Germination and total yield was strongly correlated (r=0.66) while the length and internode length of the plants recorded a very high correlation coefficient (r=0.91). In 2015 and 2016, of the pairwise combinations assessed, 28 combinations yielded correlation coefficients between 0.40 and 0.85. The results are presented in the pairwise correlation matrices below.

<<bz, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 7, fig.cap = "Correlation Plot for Bozeman in 2016">>=
##########################
# Bozeman 2016 Dataset  #
#########################

##Load Data (Bozeman 2016)
bozeman16<-bz16
#summary(bozeman16)

##Relabel Names
#names(bozeman16)

library(data.table)

##Relabeling COlumns
colnames(bozeman16)[colnames(bozeman16)=="pctg_Lodging_boze_2016"] <- "prcnt_lodging"
colnames(bozeman16)[colnames(bozeman16)=="GerminateNABozemanNA2016"] <- "germ"
colnames(bozeman16)[colnames(bozeman16)=="Avg_brnch_numb_boz_2016"] <- "branch_numb"
colnames(bozeman16)[colnames(bozeman16)=="avg_height_boze_2016"] <- "avg_plant_height"
colnames(bozeman16)[colnames(bozeman16)=="avg_length_boze_2016"] <- "avg_plant_length"
colnames(bozeman16)[colnames(bozeman16)=="Mat_time_boze_2016"] <- "mat_time"
colnames(bozeman16)[colnames(bozeman16)=="avg_tend_length_boze_2016"] <- "tendril_length"
colnames(bozeman16)[colnames(bozeman16)=="Avg_Main_stem_diam_boze_2016"] <- "main_stm_diam"
colnames(bozeman16)[colnames(bozeman16)=="avg_comp_mn_stm_dia_boze_2016"] <- "c_m_stm_diam"
colnames(bozeman16)[colnames(bozeman16)=="avg_comp_brnch_diam_boze_2016"] <- "c_branch_diam"
colnames(bozeman16)[colnames(bozeman16)=="avg_branch_diam_boze_2016"] <- "branch_diam"
colnames(bozeman16)[colnames(bozeman16)=="comp_brnch_diam_boze_2016"] <- "c_branch_diam"
colnames(bozeman16)[colnames(bozeman16)=="avg_root_diam_boze_2016"] <- "root_diam"

##Correlation
#install.packages("psych")

#pairs.panels(bozeman16)

#names(bozeman16)

##Drop Columns
bozeman16v2 <- subset(bozeman16, select = -c(Line_name, planting_generation, 
                              Unknown, dpo_boze_2016, plants_harvestedNA_Boze_2016,
                              bif_boze_2016, Yield_boze_2016,
                              white_flow_2016_boze, afila_2016_boze_) )
#names(bozeman16v2)

##Reorder Colums
bozeman16v3 = bozeman16v2[, c(5,2,3,4,6,1,7:12)]
#names(bozeman16v3)
#pairs.panels(bozeman16v3)
correlation.2 <- cor(na.omit(bozeman16v3[,c(1,2,3,4,5,6,7,8,9,10,11,12)]))
corrplot(correlation.2, type = "lower" ,method = "number", tl.cex = .7, number.cex = .6,bg = "black")
title("Bozeman2016")
@

<<nextchunk1, message = FALSE, warning = FALSE, fig.cap = "Correlation Matrix for Bozeman in 2014" >>=
##########################
# Bozeman 2014 Dataset  #
#########################

##Load Data (Bozeman 2014)
bozeman14<-bz14
#summary(bozeman14)
#names(bozeman14)

##Relabeling COlumns
colnames(bozeman14)[colnames(bozeman14)=="Prcnt.Lodging"] <- "pct_lodging"
colnames(bozeman14)[colnames(bozeman14)=="Germination.2014.."] <- "germ"
colnames(bozeman14)[colnames(bozeman14)=="branch.numb.2014"] <- "branch_numb"
colnames(bozeman14)[colnames(bozeman14)=="height"] <- "plant_height"
colnames(bozeman14)[colnames(bozeman14)=="length"] <- "plant_length"
colnames(bozeman14)[colnames(bozeman14)=="tendril.length.14.node.2014"] <- "tendril_length_node"
colnames(bozeman14)[colnames(bozeman14)=="tendril.length.2014"] <- "tendril_length"
colnames(bozeman14)[colnames(bozeman14)=="Nodes.1st.flow.2014"] <- "nodes_1st_flow"
colnames(bozeman14)[colnames(bozeman14)=="max.nodes.2014"] <- "max_nodes"
colnames(bozeman14)[colnames(bozeman14)=="internode.length.2014"] <- "internode_length"
colnames(bozeman14)[colnames(bozeman14)=="Total.yield.2014"] <- "total_yield"
colnames(bozeman14)[colnames(bozeman14)=="Avg.Yld.Plant.2014"] <- "avg_total_yield"
colnames(bozeman14)[colnames(bozeman14)=="Main.stm.diameter.2014"] <- "main_stm_diam"
colnames(bozeman14)[colnames(bozeman14)=="Average.compressed.main.stem.thickness.2014"] <- "comp_main_stm"
colnames(bozeman14)[colnames(bozeman14)=="Tiller.diameter.2014"] <- "tiller_diam"
colnames(bozeman14)[colnames(bozeman14)=="compressed.tiller.thickness.2014"] <- "c_tiller_diam"
colnames(bozeman14)[colnames(bozeman14)=="length.1"] <- "length_1"

##Drop Columns

bozeman14 <- subset(bozeman14, select = -c(DNA.GENERATION, LINE.., Germination.2014NACHECKED, 
   stand.good.1.Y..2.bad.sample..do.not.use.lines.labeled.2, 
   prcnt.lodging.bad.germ.lines.includedNAchecked, flowering.time.2014,
   white.flower..1.is.white, black.hilum.delta.A.NO.MOT, 
   Brown.mottle..rerate.next.year..1.no.mot, np.neo, Late,
   tall.dwf.based.on.grnhouse.data..field.2014, Afila.1.YES.DELTA.A))

#names(bozeman14)
bozeman141 <- bozeman14

##Reorder Colums
bozeman14 = bozeman141[, c(5,2,3,4,1,7,13,6,8,9,12,15,10,11,15,16)]
#names(bozeman14)

##Plot Correlation
#pairs.panels(bozeman14) #Is too big...
correlation.3 <- cor(na.omit(bozeman14[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)]))
#corrplot.mixed(correlation.3, tl.pos = "lt")
corrplot(correlation.3, type = "lower", method ="square",number.cex = .6) 
title("Bozeman 2014")
@

<<nextchunk, message = FALSE, warning = FALSE, fig.cap = "Correlation Matrix for Bozeman in 2015" >>=
#########################
# Bozeman 2015 Dataset  #
#########################

##Load Data (Bozeman 2015)
bozeman15<-bz15
#summary(bozeman15)
#names(bozeman15)

##Relabeling COlumns
colnames(bozeman15)[colnames(bozeman15)=="Yield"] <- "yield"
colnames(bozeman15)[colnames(bozeman15)=="X..GERMINATION.AVG.with.bad.germinating.lines.left.in.and.adjusted.for.seeds.planted"] <- "avg_germ"
colnames(bozeman15)[colnames(bozeman15)=="X..of.branch"] <- "branch_numb"
colnames(bozeman15)[colnames(bozeman15)=="plants.harvested"] <- "plants_har"
colnames(bozeman15)[colnames(bozeman15)=="X..Lodging"] <- "pct_lodging"
colnames(bozeman15)[colnames(bozeman15)=="Average.height"] <- "plant_height"
colnames(bozeman15)[colnames(bozeman15)=="average.length..Median.2015.40NA45cm."] <- "plant_length"
colnames(bozeman15)[colnames(bozeman15)=="Mat.time"] <- "mat_time"
colnames(bozeman15)[colnames(bozeman15)=="tendril.width"] <- "tend_wid"
colnames(bozeman15)[colnames(bozeman15)=="tendril.Length"] <- "tendril_length"
colnames(bozeman15)[colnames(bozeman15)=="Nodes.1st.flow"] <- "nodes_1st_flow"
colnames(bozeman15)[colnames(bozeman15)=="max.nodes"] <- "max_nodes"
colnames(bozeman15)[colnames(bozeman15)=="main.stem.DIAm.avg"] <- "main_stem_diam"
colnames(bozeman15)[colnames(bozeman15)=="Main.stem.comp..avg"] <- "comp_main_stem_diam"
colnames(bozeman15)[colnames(bozeman15)=="tiller.Diam.AVG"] <- "til_diam"
colnames(bozeman15)[colnames(bozeman15)=="tiller.compressed.avg"] <- "comp_til_av"
colnames(bozeman15)[colnames(bozeman15)=="Root.compressed.avg"] <- "avg_comp_root"
colnames(bozeman15)[colnames(bozeman15)=="avg.main..side.brnch.root"] <- "main_bran_rt"

##Drop Columns
bozeman15 <- subset(bozeman15, select = -c(line.., average.lodging.Moccasin.2015, AVERAGE.HEIGHT.Moccasin.2015,
                    X..germ.avg.with.bad.germ.lines.removed.and.adjusted.for.seeds.planted, 
                    X..Lodging.with.bad.germinating.lines.included, runt., white.flow., 
                    black.hilum.LG.6.delta.A.NO.MOT, Brown.mottle..rerate.next.year..1.no.mot, 
                    np.neo, Late.2015, average.length.2015, tall.dwf.based.on.grnhouse.data..field.2015, 
                    AVERAGE.HEIGHT.Moccasin.2015..43NA58., X, Afila.2015, afilaNAdwf.only))

bozeman151 <- bozeman15
##Reorder Colums
bozeman15 = bozeman151[, c(5,3,6,7,2,10,13,11,12,15,16,1,2,4,8,9,14)]
#names(bozeman15)

##Plot Correlation
#install.packages("psych")
require(psych)
#pairs.panels(bozeman15)
correlation.4 <- cor(na.omit(bozeman15[,1:16]))
corrplot(correlation.4,type = "lower", method = "square",number.cex = .5)
title("Bozeman 2015")
@

\subsection{Moccasin by Year}
Examining the phenotypes at Moccasin in each year, we can see that several of the variables were relatively highly correlated in 2016. The strongest correlations were between tendril length and plant length, which makes sense, as well as between percent lodging and plant length. While none of the correlations would be interpreted as very strong, there are moderate postive and negative relationships in both years. 



<<moc, warning = FALSE, message = FALSE, fig.width = 7, fig.heigh = 7,  fig.cap = "Correlation Matrix for Moccasin in 2016">>=

##########################
# Mocassin 2016 Dataset  #
#########################

##Load Data (Moccasin 2016)
moccasin16<- moc16
#summary(moccasin16)

##Relabel Names
#names(moccasin16)

library(data.table)



##Relabeling COlumns
#colnames(moccasin16)[colnames(moccasin16)=="pctg_Lodging_boze_2016"] <- "pct_lodging"
colnames(moccasin16)[colnames(moccasin16)=="X..GerminationNAMoccasinNA2016"] <- "pct_germination"
colnames(moccasin16)[colnames(moccasin16)=="Tendril.Length.2016"] <- "tendril_length"
colnames(moccasin16)[colnames(moccasin16)=="Avg.branch.number.2016"] <- "branch_numb"
colnames(moccasin16)[colnames(moccasin16)=="Mat.timeNA.MoccasinNA2016"] <- "mat_time"
colnames(moccasin16)[colnames(moccasin16)=="AVG.length.moc.2016"] <- "plant_length"
colnames(moccasin16)[colnames(moccasin16)=="X.lodging.2016"] <- "pct_lodging"
colnames(moccasin16)[colnames(moccasin16)=="Main.stem.diam.avg.2016"] <- "main_stem_diam"
colnames(moccasin16)[colnames(moccasin16)=="avg.branch.diam.2016"] <- "branch_diam"
colnames(moccasin16)[colnames(moccasin16)=="avg.root.diam.2016"] <- "root_diam"

##Drop Columns
#names(moccasin16)
moccasin16 <- subset(moccasin16, select = -c(Line.name,
                     white.flow.moc.2016.checked, afila.2016.moc.checked))
#names(moccasin16)

moccasin161<- moccasin16

##Reorder Colums
moccasin16 <- moccasin161[, c(5,3,4,2,7,1,6,8,9)]
#names(moccasin16)

##Correlation Plot

library(psych)
#pairs.panels(moccasin16)
correlation.5 <- cor(na.omit(moccasin16[,1:9]))
corrplot(correlation.5,tl.cex = .7, method = "number", type = "lower",number.cex = .8,bg = "black")
title("Moccasin 2016")
@
\pagebreak
In Moccasin in 2015, several notable correlations were found. Stress minus equation was strongly negatively correlated with tiller diameter, tiller compressed, tiller compressed flex, and flex after crushing. Lodging was found to be correlated with plant height as expected. 

<<Moc15, message = FALSE, warning = FALSE, fig.width = 8 ,fig.height = 7,  fig.cap = "Correlation Matrix for Moccasin in 2015">>=
##########################
# Moccasin 2015 Dataset  #
#########################

##Load Data (Moccasin 2015)
moccasin15<-moc15
#summary(moccasin15)
#names(moccasin15)

##Relabeling Columns
colnames(moccasin15)[colnames(moccasin15)=="Lodging"] <- "pct_lodging"
colnames(moccasin15)[colnames(moccasin15)=="stress.minus.equation"] <- "stress_m_eqn"
colnames(moccasin15)[colnames(moccasin15)=="original.stress.equation"] <- "ognl_stress_eqn"
colnames(moccasin15)[colnames(moccasin15)=="stress.minus.equation.with.standard.thickness"] <- "SME_Std_thickn"
colnames(moccasin15)[colnames(moccasin15)=="Height"] <- "plant_height"
colnames(moccasin15)[colnames(moccasin15)=="main.stem.DIAm.3"] <- "main_stem_diam"
colnames(moccasin15)[colnames(moccasin15)=="tiller.Diam.3"] <- "tiller_diam"
colnames(moccasin15)[colnames(moccasin15)=="tiller.compressed.3"] <- "tiller_comp"
colnames(moccasin15)[colnames(moccasin15)=="till.comp.flex"] <- "till_comp_flex"
colnames(moccasin15)[colnames(moccasin15)=="Flex.after.crushing"] <- "flex_crush"
colnames(moccasin15)[colnames(moccasin15)=="Root"] <- "root"

##Drop Columns
#names(moccasin15)

moccasin15 <- subset(moccasin15, select = -c(X))
moccasin151 <- moccasin15

#names(moccasin15)

##Plot Correlation
#pairs.panels(moccasin15)
correlation.15 <- cor(na.omit(moccasin15[,c(1,5,6,7,8,9,2,3,4,10,11)]))
corrplot(correlation.15,type = "lower",method ="number",number.cex = .65,bg="black", main = "Moccasin 2015",mar = c(1,1,1,1))
@

<<MocAllYear, message = FALSE, warning = FALSE, fig.width = 8 ,fig.height = 7,  fig.cap = "Correlation Matrix for Moccasin (In All Years)">>=
##########################
# Mocassin Merged Dataset  #
#########################

##Load Data (Moccasin Merged)
#setwd("C:/Users/Paul/Documents")
mergedmc<-read.csv("Merged Moccasin.csv",header=T)
#summary(mergedmc)
#names(mergedmc)

##Relabeling COlumns
library(data.table)


#colnames(mergedmc)[colnames(mergedmc)=="pctg_Lodging_boze_2016"] <- "pct_lodging"
colnames(mergedmc)[colnames(mergedmc)=="X..GerminationNAMoccasinNA2016"] <- "pct_germ"
colnames(mergedmc)[colnames(mergedmc)=="Tendril.Length.2016"] <- "tendril_length"
colnames(mergedmc)[colnames(mergedmc)=="Avg.branch.number.2016"] <- "branch_numb"
colnames(mergedmc)[colnames(mergedmc)=="Mat.timeNA.MoccasinNA2016"] <- "maturity_time"
colnames(mergedmc)[colnames(mergedmc)=="AVG.length.moc.2016"] <- "plant_length"
colnames(mergedmc)[colnames(mergedmc)=="X.lodging.2016"] <- "prcnt_lodging"
colnames(mergedmc)[colnames(mergedmc)=="Main.stem.diam.avg.2016"] <- "main_stm_diam"
colnames(mergedmc)[colnames(mergedmc)=="avg.branch.diam.2016"] <- "branch_diam"
colnames(mergedmc)[colnames(mergedmc)=="avg.root.diam.2016"] <- "root_diam"

##Drop Columns
#names(mergedmc)
mergedmc <- subset(mergedmc, select = -c(Line.name,
                                             white.flow.moc.2016.checked, afila.2016.moc.checked
                                         ))
mergedmc <- subset(mergedmc, select = -c(pct_germ, tendril_length, branch_numb,
                                         maturity_time, branch_diam))
#names(mergedmc)

##Reorder Colums
mergedmc = mergedmc[, c(2:1, 3:4)]
#names(mergedmc)

##Correlation Plot
#pairs.panels(moccasin16,smooth = FALSE, scale = TRUE, density = TRUE, ellipses = FALSE)
correlation.6 <- cor(na.omit(mergedmc))
corrplot(correlation.6, type = "lower", method = "number", number.cex = .8, bg ="black", tl.cex = .7, mar = c(1,2,1,2), main = "Moccasin in All Years")

@
\pagebreak

\section{Site Year Combinations for Lodging}
<<intro, include = FALSE >>=
bz13 <- read.csv("JaminB13.csv", header = TRUE)
bz14 <- read.csv("JaminB14.csv", header = TRUE)
bz15 <- read.csv("JaminB15edited.csv", header = TRUE)
bz16 <- read.csv("JaminB16edited.csv", header = TRUE)
moc15 <- read.csv("JaminM15edited.csv", header = TRUE)
moc16 <- read.csv("JaminM16edited.csv", header = TRUE)

#create and add in variables for each site/year combination
bz13$Site <- bz14$Site <- bz15$Site <- bz16$Site <- "Bozeman"
moc15$Site <- moc16$Site <- "Moccasin"
bz13$Year <- 2013
bz14$Year <- 2014
bz15$Year <- moc15$Year <- 2015
bz16$Year <- moc16$Year <- 2016

#Merge into a single dataset
#lodging response

# there appears to have been different numbers of varieties in
# different years, assuming the first 257 in each data set
# represents the same varieties, I subsetted the envXyear
# comb to only include the first 257 observations
lodging <- NULL
lodging<- c(bz14$Prcnt.Lodging,bz15$X..Lodging,bz16$pctg_Lodging_boze_2016,moc15$Lodging,moc16$X.lodging.2016)

#site year combo as a factor
site <- c(bz14$Site,bz15$Site, bz16$Site,moc15$Site,moc16$Site)
year <- c(bz14$Year, bz15$Year,bz16$Year,moc15$Year,moc16$Year)
siteyear <- as.factor(paste(site,year, sep = ""))

year.site.mat <- data.frame(cbind(lodging,site,year,siteyear))
year.site.mat$lodging <- as.numeric(year.site.mat$lodging)

@



\subsection{Exploratory Analysis} 
The data were collected over a period of 4 field seasons at sites in Bozeman and 2 field seasons in Moccasin. Phenotypic data were analyzed in order to determine whether conditions were similar enough at each year/site combination to consider as a single dataset, or if they differ by enough that the sites and years need to be considered as different groups.  

Though QTL analyses of all phenotypic traits is of interest, lodging is considered the primary response. Therefore, we examine the Percent Lodging measured at each site/year combination. Note that Percent Lodging is not measured in the 2013 Bozeman data; we did not include it in this analysis.

Visually, we can create beanplots (Kampstra 2008) to assess the differences mean percent lodging at each year/site combination.  These show both the variability of the distribution, like a traditional boxplot would, as well as information about the skew and modes. Over all years in Bozeman it appears that the distribution of lodging was slightly more variable than for sites in Moccasin; however, for some reason in 2016 the Bozeman site exhibited positive skew.  This indicates that in 2016, the majority of pea plants were lodged to a lesser degree than in 2015 or 2014.  The thin horizontal black bars indicate the original data values; the bold black lines indicate group means. 


<<meanvars, include = TRUE, eval = TRUE, warning = FALSE, fig.cap = "Comparative Beanplot of Site/Year Combinations">>=
#plots of percent lodging at each site #means
a <- mean(bz14$Prcnt.Lodging, na.rm = TRUE)
b <- mean(bz15$X..Lodging, na.rm = TRUE)  
c <-mean(bz16$pctg_Lodging_boze_2016, na.rm = TRUE)  
d <- mean(moc15$Lodging, na.rm = TRUE) 
e <- mean(moc16$X.lodging.2016, na.rm = TRUE) 

#var
a.var <- var(bz14$Prcnt.Lodging, na.rm = TRUE)
b.var <- var(bz15$X..Lodging, na.rm = TRUE)  
c.var <-var(bz16$pctg_Lodging_boze_2016, na.rm = TRUE)  
d.var <- var(moc15$Lodging, na.rm = TRUE) 
e.var <- var(moc16$X.lodging.2016, na.rm = TRUE) 

#Bean Plots (Side by Side)
library(beanplot)
set.seed(2062017)
beanplot(lodging~siteyear, cex = .8, col = c("gold2","black","red","blue"), main = "Lodging at each site/year combination", ylab = "Percent Lodging", names = c("BZ14","BZ15","BZ16","Moc15","Moc16"), method = "jitter", cutmin = -1)

@


\subsection{Interaction Plot}
If the sites are reasonably similar, we would expect to see parallel lines that are either overlapping or very near each other.  The dashed red line for Bozeman indicates that average percent lodging was higher in Bozeman than in Moccasin in both 2015 and 2016.  The bars indicate the variability of lodging for each year in Bozeman - it appears that for most years, Bozeman was slightly more variable than Moccasin. While the blue line and red line are both decreasing from 2015 to 2016, the difference in slopes indicates that there may be some interaction between year/site combinations.  This visualization indicates some evidence of a difference in lodging in each location and year. However, since there are no observations from Moccasin in 2014, we cannot formally test for a site by year interaction. 

<<tables, include = TRUE, warning = FALSE, message = FALSE, fig.cap = "Interaction Plot for Sites and Years">>=
#display a better interaction plot with results
intplot<-function (formula = NULL, data = NULL, type = "b", x.cont = FALSE, 
          legend = TRUE, trace.label = NULL, leg.lab = NULL, fixed = FALSE, 
          x.leg = NULL, y.leg = NULL, cex.leg = 1, ncol = 1, pch = c(16, 
                                                                     21, 15, 22, 17, 24, c(3:14)), fun = function(x) mean(x, 
                                                                                                                          na.rm = TRUE), ci.fun = function(x) c(fun(x) - se(x), 
                                                                                                                                                                fun(x) + se(x)), err.width = if (length(levels(as.factor(x.factor))) > 
                                                                                                                                                                                                   10) 0 else 0.1, err.col = col, err.lty = 1, xlim = NULL, 
          ylim = NULL, cex = NULL, lwd = NULL, col = "black", cex.axis = 1, 
          xaxt = "s",main=NULL ,cld=F, cldshift=0.1,cldcol="white", ...) 
{
  #Modifications by Mark Greenwood, September, 2014 based on interface from compareCatsL by Bryan Hanson, DePauw Univ, Jan 2010 and using the lineplot.CI from the sciplot package
  
  se<-function (x, na.rm = TRUE){ sqrt(var(x, na.rm = na.rm)/length(x[complete.cases(x)]))}
  
  fun <- eval(substitute(fun), envir = data)
  ci.fun = eval(substitute(ci.fun),envir=data)
    
    #
  
  
      response <- eval(parse(text=as.character(formula[[2]])),data)
      respname<-formula[[2]]
      x.factor <- factor(eval(parse(text=as.character(formula[[3]][3])),data))
      xfname<-((formula[[3]][[3]]))
      group <- factor(eval(parse(text=as.character(formula[[3]][2])),data))
      grpname<-(formula[[3]][[2]])
        
    #
    
    
   
  subset = NULL
  int.plot <- function(x.factor = x.factor, group = group, 
                       response = response, type = c("l", "p", "b"), legend = legend, 
                       trace.label = deparse(substitute(group)), fixed = FALSE, 
                       xlab = deparse(xfname), ylab = ylabel, 
                       lty = nc:1, pch = NA, xpd = NULL, leg.bg = par("bg"), 
                       leg.bty = "n", xtick = FALSE, xlim = xlim, ylim = ylim, 
                       axes = TRUE, ...) {
    ylabel <- paste("Mean of ", deparse(respname), "plus/minus 1 SE")
    mainlabel=main
    if (is.null(mainlabel))    mainlabel<- paste("Interaction plot of", deparse(respname), "based on",deparse(xfname), "and", deparse(grpname) )
    type <- match.arg(type)
    cells <- tapply(response, list(x.factor, group), fun)
    nr <- nrow(cells)
    nc <- ncol(cells)
    xvals <- if (x.cont) 
      as.numeric(levels(as.factor(x.factor)))
    else 1:nr
    if (is.ordered(x.factor)) {
      wn <- getOption("warn")
      options(warn = -1)
      xnm <- as.numeric(levels(x.factor))
      options(warn = wn)
      if (!any(is.na(xnm))) 
        xvals <- xnm
    }
    xlabs <- rownames(cells)
    ylabs <- colnames(cells)
    nch <- max(sapply(ylabs, nchar, type = "width"))
    if (is.null(xlabs)) 
      xlabs <- as.character(xvals)
    if (is.null(ylabs)) 
      ylabs <- as.character(1:nc)
    if (is.null(xlim)) {
      xlim <- range(xvals)
      xleg <- xlim[2] + 0.05 * diff(xlim)
      xlim <- xlim + c(-0.2/nr, if (legend & is.null(x.leg) & 
                                      is.null(y.leg)) 0.2 + 0.02 * nch else 0.2/nr) * 
        diff(xlim)
    }
    else {
      xlim
      xleg <- xlim[2] - 0.25 * diff(xlim)
    }
    matplot(xvals, cells, ..., type = type, xlim = xlim, 
            ylim = ylim, xlab = xlab, ylab = ylab, axes = axes, 
            xaxt = "n", col = col, lty = lty, lwd = lwd, pch = pch,main=mainlabel)
    if (axes && xaxt != "n") {
      axisInt <- function(x, main, sub, lwd, bg, log, asp, 
                          ...) axis(1, x, ...)
      mgp. <- par("mgp")
      if (!xtick) 
        mgp.[2] <- 0
      axisInt(1, at = xvals, labels = xlabs, tick = xtick, 
              mgp = mgp., xaxt = xaxt, ...)
    }
    ord <- sort.list(cells[nr, ], decreasing = TRUE)
    if (legend) {
      yrng <- diff(ylim)
      yleg <- ylim[2] - 0.1 * yrng
      if (!is.null(xpd) || {
        xpd. <- par("xpd")
        !is.na(xpd.) && !xpd. && (xpd <- TRUE)
      }) {
        op <- par(xpd = xpd)
        on.exit(par(op))
      }
      text(xleg, ylim[2] - 0.05 * yrng, paste("  ", trace.label), 
           adj = 0)
      if (!fixed) {
        ylabs <- ylabs[ord]
        lty <- lty[1 + (ord - 1)%%length(lty)]
        col <- col[1 + (ord - 1)%%length(col)]
        pch <- pch[ord]
      }
    }
    invisible()
    return.data <- if (legend) 
      list(pch = pch, ord = ord, xleg = xleg, yleg = yleg, 
           ylabs = ylabs, lty = lty, leg.bty = leg.bty, 
           leg.bg = leg.bg, ord = ord, xvals = xvals, cells = cells)
    else list(pch = pch, ord = ord, xvals = xvals)
    return(return.data)
  }
  if (length(group[[1]]) > 1) 
      group <- factor(interaction(group, lex.order = TRUE))
    group <- factor(group)
    groups <- list(x.factor, group)
  
  mn.data <- tapply(response, groups, fun)
  CI.data <- tapply(response, groups, ci.fun)
  plot.limits = c(min(c(unlist(mn.data), unlist(CI.data)), 
                      na.rm = TRUE), max(c(unlist(mn.data), unlist(CI.data)), 
                                         na.rm = TRUE))
  if (is.null(group)) {
    nlevels.x <- if (x.cont) 
      as.numeric(levels(as.factor(x.factor)))
    else 1:nrow(mn.data)
    plot(nlevels.x, mn.data, xaxt = "n", type = type, col = col, 
         pch = NA, cex = cex, cex.axis = cex.axis, lwd = lwd, 
         xlim = if (is.null(xlim)) {
           c(min(nlevels.x) - 0.2, max(nlevels.x) + 0.2)
         }
         else xlim, ylim = if (is.null(ylim)) 
           plot.limits
         else ylim, ...)
    if (xaxt != "n") 
      axis(1, labels = names(mn.data), at = nlevels.x, 
           cex.axis = cex.axis, ...)
  }
  else leg.vals <- int.plot(x.factor, group, response, type = type, 
                            xlim = xlim, ylim = if (is.null(ylim)) 
                              plot.limits
                            else ylim, cex.axis = cex.axis, trace.label = trace.label, 
                            pch = NA, legend = legend, ...)
  if (is.null(group)) {
    nlevels.x <- if (x.cont) 
      as.numeric(levels(as.factor(x.factor)))
    else 1:nrow(mn.data)
    CI.seln <- !is.na(mn.data)
    CI.plot <- matrix(unlist(CI.data[CI.seln]), nrow = sum(CI.seln), 
                      byrow = TRUE)
    arrows(nlevels.x[CI.seln], CI.plot[, 1], nlevels.x[CI.seln], 
           CI.plot[, 2], angle = 90, col = err.col, length = err.width, 
           code = 3, lwd = lwd, lty = err.lty)
  }
  else {
    nlevels.y <- ncol(mn.data)
    for (i in 1:nlevels.y) {
      CI.seln <- !is.na(mn.data)[, i]
      CI.plot <- matrix(unlist(CI.data[CI.seln, i]), nrow = sum(CI.seln), 
                        byrow = TRUE)
      arrows(leg.vals$xvals[CI.seln], CI.plot[, 1], leg.vals$xvals[CI.seln], 
             CI.plot[, 2], angle = 90, length = err.width, 
             col = if (length(err.col) > 1) 
               err.col[i]
             else err.col, lty = if (length(err.lty) > 1) 
               err.lty[i]
             else err.lty, code = 3, lwd = lwd)
    }
  }
  if (type %in% c("p", "b")) {
    if (is.null(group)) {
      nlevels.x <- if (x.cont) 
        as.numeric(levels(as.factor(x.factor)))
      else 1:nrow(mn.data)
      points(nlevels.x, mn.data, pch = pch[1], bg = "white", 
             cex = cex, col = col)
    }
    else {
      nlevels.y <- dim(mn.data)[2]
      for (i in 1:nlevels.y) points(leg.vals$xvals, mn.data[, 
                                                            i], pch = pch[i], bg = "white", col = if (length(col) > 
                                                                                                        1) 
                                                              col[i]
                                    else col, cex = cex)
    }
  }
  if (legend & !is.null(group)) {
    legend(x = if (is.null(x.leg)) 
      leg.vals$xleg
      else x.leg, y = if (is.null(y.leg)) 
        leg.vals$yleg
      else y.leg, legend = if (!is.null(leg.lab)) 
        leg.lab
      else {
        if (fixed) 
          levels(as.factor(unlist(group)))
        else leg.vals$ylabs
      }, pch = if (type %in% c("p", "b")) {
        if (!fixed) 
          pch[leg.vals$ord]
        else pch
      }, col = if (type %in% c("p", "b")) {
        if (!fixed & length(col) > 1) 
          col[leg.vals$ord]
        else col
      }, lty = if (type %in% c("l", "b")) {
        if (fixed) 
          leg.vals$lty[order(leg.vals$ord)]
        else leg.vals$lty
      }, ncol = ncol, bty = leg.vals$leg.bty, bg = leg.vals$leg.bg, 
      cex = cex.leg)
  }
  if (cld==T){
    #First, flatten two way model and run Tukey HSD
    #Create interaction version of two-way ANOVA model:
    intvar<-interaction(x.factor,group)
    require(multcomp)
    cldres<-cld(glht(lm(response~intvar),linfct=mcp(intvar="Tukey")))
    ymeans<-predict(lm(response~intvar),newdata=data.frame(intvar=levels(intvar)))
    #Then put letters from compact letter display (CLD) on the plot at close to correct locations
    if (cldcol=="white"){cldcol<-as.numeric((data.frame(cldres$mcletters$Letters))[,1])+1}
    #Need x-location from x.factor
    text(x=rep(1:length(levels(x.factor)),length(unique(group))),y=ymeans+cldshift, labels=cldres$mcletters$Letters,col=cldcol,cex=1.3*cex.axis)
    
    
  }
  
  invisible(list(vals = mn.data, CI = CI.data))
}

intplot(lodging ~ site * year, col = c("red","blue"), lwd = 2)

@

\pagebreak
\subsection{Regression Model and Pairwise Comparisons}
A model was fit to include all site and year combinations in order to test for differences between the combinations. Bozeman 2014 was treated as the baseline group. An overall F test using 4 and 1205 degrees of freedom to assess evidence against all site-year combinations yields a p-value less than 0.000001. There is strong evidence that the site/year combinations do not have all the same mean percent lodging. 
  
We include 95 percent confidence intervals for the true mean percent lodging at each site-year combination. In order to get a better sense for which groups differ, we performed Tukey-Kramer pairwise comparisons to adjust for multiple testing. The results of that analysis are included below. The plot below shows differing pairwise combinations were between Bozeman 2015 and Bozeman 2014, as well as between Moccasin 2015 and Bozeman 2016, and between Moccasin 2016 with Bozeman in 2015 and 2016. Given that Bozeman 2015 had such a large mean relative to the other site/year combinations, this is not a surprising result. 
  
\includegraphics [width = 4.5 in] {RegressionResults}
<<regression, include = FALSE, eval = TRUE, warning = FALSE, message = FALSE>>=
#Fit A Simple Regression:
library(pander)
# list() issues, with , na.action = na.omit -- removed
lm.lodging <- lm(lodging ~ siteyear, data = year.site.mat, na.action = na.omit)
summary(lm.lodging)$fstat #gives the f-stat included in the above image
summary(lm.lodging)

#fit cell means model
lm.cellmeans <- lm(lodging ~ siteyear -1, data = as.data.frame(year.site.mat), na.action = na.omit)
summary(lm.cellmeans)
confint(lm.cellmeans)
 #gives a better confidence interval summarized in Regression Results document
@

<<tukey, include = TRUE, eval = TRUE, warning = FALSE, message = FALSE, fig.cap = "Multiple Comparisons of Lodging at Sites and Years">>=
#Tukey HSD comparisons
diffs <- TukeyHSD(aov(lodging~siteyear))
col <- ifelse(diffs$siteyear[,4]>.05,"blue","red")
par(mar = c(2.5,10,3.5,1))
plot(diffs, col = col, cex.axis = .7, las = 2)


@


\subsection{Discussion}
This analysis indicates that the measurements taken at each site in each year should be treated separately; they should not be considered homogeneous enough to be taken as a single group.  The inclusion of 2013 into the data is unlikely to change the results of this study because the differences between the combinations already considered are enough to justify splitting the dataset into separate groups.  However, it may facilitate future calculations to consider converting lodging measurements in Bozeman in 2013 from likert-scale format (on a 1-4 scale) to the same "percent-lodging" variable that is used in subsequent years. 


\pagebreak
\section{Missing Genetic Data}
Quality of the genetic data can be explored through the percentage of varieties missing information at each genetic marker. Reviewing QTL literature may provide insight to acceptable missing rates. Plots are provided below to visualize the amount of missing data at each genetic marker and across each variety genotyped. Tables of missing rates are provided in the appendix. As the number of genetic markers and varieties are large, the tables will be more informative on the exact varieties with certain missing rates. Rates of missing-ness at each genetic marker are first shown across all makers, and then are broken into plots subsetted by genetic markers with less than 25\% missing, less than between 25\% and 30\% missing, less than between 30\% and 35\% missing, and less than between 35\% and 40\%. All genetic markers had at least 60\% of the data across all varieties.

\subsection{All Markers}

<<missing.plot, fig.cap = 'Missing Genetic Data Plot'>>=

ggplot(datf1_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 90, hjust = 1, size = 0.5), 
        axis.text.y = element_blank()) + coord_flip()
@

<<missing.pattern, include = FALSE>>=
#str(md.pattern(gen))
colnames(gen)

gen_markers <- gen[,-610]
dim(gen_markers)
marker_miss <- apply(gen_markers,2,function(t){length(which(is.na(t) == TRUE))})
variety_miss <- apply(gen_markers,1,function(t){length(which(is.na(t) == TRUE))})

marker_miss
# give the percent that is missing
# both across markers and across varieties
marker_miss.percent <- marker_miss/dim(gen_markers)[2]
variety_miss.percent <- variety_miss/dim(gen_markers)[1]

mmiss <- data.frame(rbind(marker_miss, marker_miss.percent))
rownames(mmiss) <- c("Count", "Percent")

vmiss <- data.frame(rbind(variety_miss, variety_miss.percent))
rownames(vmiss) <- c("Count", "Percent")
@
\pagebreak

\subsection{Less than 25\% Missing by Genetic Marker}

<<subset.25, warning = FALSE>>=
mmiss25 <- which(mmiss[2,] <= 0.25)
mmiss30 <- which(0.25 < mmiss[2,] & mmiss[2,]<= 0.30)

mmiss35 <- which(0.30 < mmiss[2,] & mmiss[2,]<= 0.35)
mmiss40 <- which(0.35 < mmiss[2,] & mmiss[2,]<= 0.40)
mmiss45 <- which(0.40 < mmiss[2,] & mmiss[2,]<= 0.45)
mmiss50 <- which(0.45 < mmiss[2,] & mmiss[2,]<= 0.50)


#mmiss.all <- c(mmiss25,mmiss50,mmiss75,mmiss100)
#good
#mmiss.all %in% c(seq(1:610))
#colnames(gen[,2:610])

dat25_bz16 <- melt(gen[,c(mmiss25,610)], id.var = 'ind', na.rm = FALSE)
dat25_bz16$value <- factor(dat25_bz16$value, levels = c("A","B","missing"))
dat25_bz16[is.na(dat25_bz16)] <- "missing"

dat30_bz16 <- melt(gen[,c(mmiss30,610)], id.var = 'ind', na.rm = FALSE)
dat30_bz16$value <- factor(dat30_bz16$value, levels = c("A","B","missing"))
dat30_bz16[is.na(dat30_bz16)] <- "missing"


dat35_bz16 <- melt(gen[,c(mmiss35,610)], id.var = 'ind', na.rm = FALSE)
dat35_bz16$value <- factor(dat35_bz16$value, levels = c("A","B","missing"))
dat35_bz16[is.na(dat35_bz16)] <- "missing"

dat40_bz16 <- melt(gen[,c(mmiss40,610)], id.var = 'ind', na.rm = FALSE)
dat40_bz16$value <- factor(dat40_bz16$value, levels = c("A","B","missing"))
dat40_bz16[is.na(dat40_bz16)] <- "missing"

dat45_bz16 <- melt(gen[,c(mmiss45,610)], id.var = 'ind', na.rm = FALSE)
dat45_bz16$value <- factor(dat45_bz16$value, levels = c("A","B","missing"))
dat45_bz16[is.na(dat45_bz16)] <- "missing"

dat50_bz16 <- melt(gen[,c(mmiss50,610)], id.var = 'ind', na.rm = FALSE)
dat50_bz16$value <- factor(dat50_bz16$value, levels = c("A","B","missing"))
dat50_bz16[is.na(dat50_bz16)] <- "missing"
@


<<missing.plot25, fig.height=7, warning=FALSE, fig.cap = "Less Than 25 Percent Missing">>=

ggplot(dat25_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data: < 25% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 10), 
        axis.text.y = element_text(angle = 0, hjust = 1, size = 10)) + coord_flip()
@

\newpage

\subsection{25\% - 30\% Missing by Genetic Marker}

<<missing.plot30,fig.height=7, warning = FALSE, fig.cap = "25-30 Percent Missing Data">>=

ggplot(dat30_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data: 25% - 30% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 1), 
        axis.text.y = element_text(angle = 0, hjust = 1, size = 1)) + coord_flip()
@

\newpage


\subsection{30\% - 35\% Missing by Genetic Marker}


<<missing.plot35, fig.height=7, warning = FALSE, message = FALSE, fig.cap = "30-35 Percent Missing Data">>=

ggplot(dat35_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data: 30 % - 35% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 1), 
        axis.text.y = element_text(angle = 90, hjust = 1, size = 1)) + coord_flip()
@

\newpage

\subsection{35\% - 40\% Missing by Genetic Marker}


<<missing.plot40, fig.height=7, warning = FALSE, message = FALSE, fig.cap="35-40 Percent Missing Data">>=

ggplot(dat40_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data < 35 % - 40% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 1), 
        axis.text.y = element_text(angle = 90, hjust = 1, size = 1)) + coord_flip()
@

\newpage

<<missing.plot45,fig.height=7, include = FALSE, eval = FALSE, fig.cap="40-45 Percent Missing Data">>=
# 0 markers had more than 40% missing, so not needed
ggplot(dat45_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data < 40 % - 45% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 1), 
        axis.text.y = element_text(angle = 90, hjust = 1, size = 1)) + coord_flip()
@

\newpage

<<missing.plot50, fig.height=7, include = FALSE, eval = FALSE, fig.cap="45-50 Percent Missing Data">>=

ggplot(dat50_bz16, aes(variable, ind)) + geom_tile(aes(fill = value),
   colour = "white")  +   scale_fill_manual(values = c("green", "blue","red"),
                                            guide = guide_legend(title = "") ) + 
  ggtitle("Genetic Data < 45 % - 50% Missing") +
 xlab("Genetic Marker") + ylab("Variety") +
  theme(legend.position = "bottom", legend.title = element_text(""),
        axis.text.x = element_text(angle = 90, hjust = 1, size = 1), 
        axis.text.y = element_text(angle = 90, hjust = 1, size = 1))
@



<<miss7,include=FALSE, eval = FALSE>>=
setwd("C:/Users/Andrea Mack/Desktop/mack_hub/course_work/Consulting Seminar/seminar_f16/datasent102516")

#start with bz16
phen_bz16 <- read.csv("Final Data Files-lodging files 10-13-2016-2015bz.csv")
str(phen_bz16)
dim(phen_bz16)

rownames(gen)
phen_bz16[phen_bz16 == "-"] <- NA
summary(phen_bz16)

#heatmap(gen)
@




\section{Setting Significance Thresholds}

The pea genetic data include over 600 genetic markers. When a QTL analysis is done, a significance test is done at each genetic marker to test for an association between the average quantiative trait and the genotype. Multiple testing problems are quite common in genetic analyses. Jamin mentioned he would like to use LOD for setting a significance threshold. LOD is an abbreviation for the log-odds. LOD is the $log_{10}$ likelihood ratio comparing the null that there is not a QTL to the alternative, that there is.

Null Model, $H_{o}: y_{i} \sim N(\mu, \sigma^2)$ i.e., there is no genetic dependency between the phenotype and the genotype. We define the Residual Sum of Squares ($RSS_{0}$) to be the squared difference between the expected mean lodging for each marker and the overall mean lodging under the null model. 

- Where the maximum likelihood estimates (MLEs) for parameter estimates $\mu = \bar{y}; \sigma^2 = RSS_{o}/n$ are used.

Alternative Model, $H_{a}: y_{i}|g_{i} \sim N(\mu_{g_{i}}, \sigma^2)$

- Where $g_{i}$ = genotype of individual i at the marker (loci); each genotype group has a different mean; $\sigma^2$ = pooled RSS = $RSS_{1}$; again the MLEs. 

LOD = $\frac{n}{2} \times log_{10}(\frac{RSS_{o}}{RSS_{1}})$

LOD is related to the F statistic. LOD = $\frac{n}{2} \times [F(\frac{df}{n-df-1} + 1)]$ and similar to the F statistic, large LOD values are associated with strong evidence against the null hypothesis, suggesting that there is a relationship between the genetic loci and the phenotype. Since F statistics help find p-values, and LOD is related to F statistics, by setting genome wide adjusted LOD thresholds, we can easily convert these back to genome wide adjusted p-values. Broman and Sen (2009) provide a simulation based method for generating genome wide adjusted LOD thresholds, and the corresponding genome-wide adjusted p-value thresholds in Section 4.3 using the {\texttt QTL} package in R (Broman et al. 2003). 

\section{Future Work}

Future work with Jamin should be more focused with the QTL analysis and developing p-value based thresholds for drawing statistical conclusions. Jamin currently is using the MapDisto macro in Excel and QTL Cartographer to do preliminary QTL analyses. Both programs provide extensive documentation on their functions. R is a common program for statisticians to use, and discussion around whether packages such as {\texttt QTL} in R or outside programs should be used in the final analysis would be beneficial. While identifying specific genetic markers associated with the most variation in phenotypic traits is the end goal of the project, a QTL analysis has many steps that should be taken before using outputted results. Broman and Sen (2009) is a good reference for a basic QTL analysis. Because Jamin is interested in genetic variation associated with all phenotypic traits, the correlations between the traits should be accounted for in the final analysis. Adding in the recommendation to not combine across sites and years, we suggest the direction of the final QTL analysis done to be in a multi-trait, multi-environment setting. A resource for an introduction to the multi-trait, multi-environment setting in QTL analyses is referenced by Margarido et al. (2015).

\newpage
\section*{References}
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{3pt}
\noindent

Margarido et al. 2015. {\it Multi-trait multi-environment quantitative trait loci mapping for a sugarcane commercial cross provides insights on the inheritance of important traits}. Mol Breeding 35:175.

Broman and Sen. 2009. {\it A guide to QTL mapping with R/QTL}. New York: Spring Science+Business Media. Retrieved from 

\url{http://link.springer.com/book/10.1007%2F978-0-387-92125-9}.

\setlength{\parindent}{0in}
\setlength{\leftskip}{0in}
\setlength{\parskip}{8pt}

\newpage


\section*{Appendix}
{\bf Tables of Missing Rates by Genetic Marker}

<<xtable.misses, results = 'asis'>>=

print(xtable(mmiss[,1:20]), scale = 0.5)
print(xtable(mmiss[,21:40]), scale = 0.5)
print(xtable(mmiss[,41:60]), scale = 0.5)
print(xtable(mmiss[,61:80]), scale = 0.5)
print(xtable(mmiss[,81:100]), scale = 0.5)
print(xtable(mmiss[,101:120]), scale = 0.5)
print(xtable(mmiss[,121:140]), scale = 0.5)
print(xtable(mmiss[,141:160]), scale = 0.5)
print(xtable(mmiss[,161:180]), scale = 0.5)
print(xtable(mmiss[,181:200]), scale = 0.5)
print(xtable(mmiss[,201:220]), scale = 0.5)
print(xtable(mmiss[,221:240]), scale = 0.5)
print(xtable(mmiss[,241:260]), scale = 0.5)
print(xtable(mmiss[,261:280]), scale = 0.5)
print(xtable(mmiss[,281:300]), scale = 0.5)
print(xtable(mmiss[,301:320]), scale = 0.5)
print(xtable(mmiss[,321:340]), scale = 0.5)
print(xtable(mmiss[,341:360]), scale = 0.5)
print(xtable(mmiss[,361:380]), scale = 0.5)
print(xtable(mmiss[,381:400]), scale = 0.5)
print(xtable(mmiss[,401:420]), scale = 0.5)
print(xtable(mmiss[,421:440]), scale = 0.5)
print(xtable(mmiss[,441:460]), scale = 0.5)
print(xtable(mmiss[,461:480]), scale = 0.5)
print(xtable(mmiss[,481:500]), scale = 0.5)
print(xtable(mmiss[,501:520]), scale = 0.5)
print(xtable(mmiss[,521:540]), scale = 0.5)
print(xtable(mmiss[,541:560]), scale = 0.5)
print(xtable(mmiss[,561:580]), scale = 0.5)
print(xtable(mmiss[,581:600]), scale = 0.5)
print(xtable(mmiss[,601:609]), scale = 0.5)
@

{\bf Tables of Missing Rates by Variety}

<<final, results = 'asis'>>=


print(xtable(vmiss[,1:20]), scale = 0.5)
print(xtable(vmiss[,21:40]), scale = 0.5)
print(xtable(vmiss[,41:60]), scale = 0.5)
print(xtable(vmiss[,61:80]), scale = 0.5)
print(xtable(vmiss[,81:100]), scale = 0.5)
print(xtable(vmiss[,101:120]), scale = 0.5)
print(xtable(vmiss[,121:140]), scale = 0.5)
print(xtable(vmiss[,141:160]), scale = 0.5)
print(xtable(vmiss[,161:180]), scale = 0.5)
print(xtable(vmiss[,181:200]), scale = 0.5)
print(xtable(vmiss[,201:220]), scale = 0.5)
print(xtable(vmiss[,221:240]), scale = 0.5)
print(xtable(vmiss[,241:257]), scale = 0.5)

# make a cross object
# the cross object function assumes markers are in the correct order


## next, subset by highest non - missing rate and remake plot
@











\end{document}
